
## 1.5 운영체제 동작

- 현대의 운영체제는 인터럽트 구동식이다. 프로세스,입출력장치,사용자가없으면 동작하지않는다.
- 사건은 거의 인터럽트나 트랩을 발생시켜 신호를 보낸다.
- **트랩**(또는 예외)은 오류(유효하지 않은 메모리 접근)혹은 사용자 프로그램의 운영체제 서비스 실행 요청에 의해 유발되는 소프트웨어에 의해 생성된 인터럽트이다.
- 운영체제의 인터럽트 구동식 특성은 시스템의 일반적 구조를 정의한다.
- 인터럽트의 행동은 서로 다른 코드 세그먼트가 결정한다.
- 하나의 인터럽트를 처리하기 위해 하나의 인터럽트 서비스 루틴이 제공된다.
- 운영체제와 사용자는 시스템의 하드웨어와 소프트웨어 자원을 공유하기 때문에 사용자 프로그램의 오류가 현제 실행 중인 프로그램에만 문제를 일으키도록 보장해야 한다.
- 공유 때문에 한 프로그램의 버그로 많은 프로그램들이 악영향을 받을 수있다.
- 올바른 운영체제는 잘못된 프로그램 때문에 다른 프로그램이 부정확하게 실행되지 않도록 해야한다.

### 이중 동작 모드(Dual-Mode Operation)

- 운영체제의 적절한 동작을 위해 운영체제 코드의 실행과 사용자 정의 코드의 실행을 구분할수 있어야 한다. 보통 여러 실행 모드 구분을 지원하는 하드웨어를 이용한다.
- 적어도 두 개의 독립된 동작 **모드**, **사용자 모드**와 **커널 모드(슈퍼바이저 모드, 시스템 모드, 특권모드**로도 부른다.)를 필여러 한다.
- **모드 비트(mode bit)** 라고 하는 하나의 비트가 현재의 모드를 나타내기 위해 컴퓨터의 하드웨어에 추가 되었다.
- 비트는 *커널 모드(0)* 또는 *사용자 모드(1)* 를 나타낸다.
- 모드 비트의 사용으로 운영체제 작업과 사용자 실행 작업을 구분 할 수 있다.
- 컴퓨터 시스템이 사용자 응용을 위해 실행될 때 시스템은 사용자 모드에 있게 된다.
  그러나 사용자 응용이 운영체제로부터 서비스를 요청하면(시스템 호출을 통함) 요청을 실행하기 위해 커널 모드로 전환해야 한다.
- 시스템 부트 시 하드웨어는 커널 모드에서 시작하며 운영체제가 적재되고 사용자 모드에서 사용자 프로세스가 시작된다.
  트랩이나 인터럽트가 발생할 때마다 하드웨어는 사용자 모드에서 커널 모드로 전환한다.(모드 비트를 0으로 변경)
- 운영체제가 컴퓨터의 제어를 얻을 때 커널 모드에 있고 시스템은 사용자 프로그램으로 제어를 넘기기 전에 사용자 모드(모드 비트를 1로 설정)로 전환한다.
- 동작의 이중 모드는 잘못된 사용자로부터 운영체제, 그리고 잘못된 사용자 서로를 보호하는 방법을 제공한다.
- 악영향을 끼칠 수 있는 일부 명령을 특권 명령(privileged instruction)으로 지정하고 보호한다.
- 하드웨어는 특권 명령이 커널 모드에서만 실행되도록 허용한다.
- 사용자 모드에서 특권 명령을 실행하면 불법적인 명령으로 간주해 운영체제로 트랩을 건다.
- 커널모드로 전환하는 명령어, 입출력 제어, 타이머 관리, 인터럽트 관리를 위한 명령어 들이 특권 명령의 예이다.
- 시스템 호출은 사용자 프로그램이 자신을 대신하여 운영체제가 실행하도록 미리 지정 되어 있는 작업들을 운영체제에게 요청 할 수 있는 방법을 제공한다.

### 타이머

- 운영체제가  CPU 제어를 유지하도록 보장해야한다. 사용자 프로그램이 무한루프나에 빠지거나 시스템 서비스를 호출하지 않아서 제어가 운영체제로 복귀하지 않는 경우 목적을 달성하기위해 **타이머**를 사용할수 있다.
- 타이머는 지정된 시간 후 컴퓨터를 인터럽트하도록 설정 할 수 있다.
- 이 시간은 고정 혹은 가변일 수 있다.
- 가변 타이머는 일반적으로 고정률의 클락(fixed-rate clock)과 계수기로 구현한다.
- 운영체제는 계수기 값을 설정한다.
  ex) 1밀리초 클락의 10비트 계수기는 1밀리초 단위로 1밀리초에서 1,024밀리초 사이의 간격을 갖는 인터럽트를 허용한다.
- 타이머가 인터럽트를 발생시키면 제어는 자동적으로 운영체제로 넘어가며 인터럽트를 오류로 취급하거나 프로그램에게 더 많은 시간을 줄 수 있다.
- 타이머 동작을 변경하는 명령은 특권 명령이다. 따라서 사용자 프로그램이 너무 오래 실행 되는 것을 방지하기 위해 타이머를 사용할 수 있다.


## 1.6 프로세스 관리

- 한 프로그램은 명령이  CPU에 의해 실행되지 않으면 아무 일도 할 수 없다. 
- 실행 중인 프로그램을 **프로세스**라 한다. 컴파일러와 같은 하나의 시분할 사용자 프로그램은 하나의 프로세스가 된다. 
- 프로세스가 병행 실행하기 위해 서브 프로세스를 생성하도록 허용하는 시스템 호출을 제공할 수있다.
- 프로세스는 실행하기 위해 CPU시간, 메모리, 파일 입출력장치등 여러 자원을 필요한다
- 이러한 자원은 프로세스가 생성될 때 제공될수도 있고 실행되는 동안 할당될 수도 있다.
- 프로세스가 생성될 때 획득하는 여러 가지 물리적 논리적인 자원 외에 여러 초기화 데이터(입력) 도 전달될 수도 있다.
- 프로그램이 프로세스가 아니다. 하나의 프로그램은 디스크에 저장된 파일의 내용과 같이 수동적 개체인 반면 프로세스는 다음 실행할 명령을 지정하는 프로그램 카운터를 가진 능동적인 개체다.
- 한 프로세스의 실행은 반드시 순차적이어야 한다. CPU는 그 프로세스가 끝날 때까지 명령들을 차례대로 실행한다.
- 두 개의 프로세스가 동일한 프로그램과 연관되어 있어도 그들은 두 개의 별도의 실행 순서로 간주된다.
- 다중 스레드 프로세스는 복수개의 프로그램 카운터를 가지며 카운터들은 각 스레드가 실행할 다음 명령어를 가리키게 된다.
- 한 프로세스는 한 시스템 내 작업의 단위다. **시스템**은 프로세스의 집합으로 구성된다.
- 프로세스중 일부는 운영체제 프로세스(시스템 코드를 실행하는 프로세스)들이며
  나머지는 사용자 프로세스(사용자 코드를 실행하는 프로세스)들이다.
- 이들 모든 프로세스는 하나의 CPU상에서 멀티플렉싱함으로써 잠재적으로 병행 실행될 수 있다.

> 운영체제는 프로세스 관리와 연관해 다음과 같은 활동에 대한 책임을 진다.
> 1. CPU에게 프로세스와 스레드 스케줄링
> 2. 사용자 프로세스와 시스템 프로세스의 생성과 제거
> 3. 프로세스의 일시 중지와 재실행
> 4. 프로세스 동기화를 위한 기법 제공
> 5. 프로세스 통신을 위한 기법 제공

## 1.7 메모리 관리

- 메모리는 워드나 바이트의 대용량 배열이다.
- 각 워드 또는 바이트는 자신의 주소를 가진다.
- 주 메모리는 CPU와 입출력장치에 의하여 공유되는 빠른 접근이 가능한 데이터의 저장소이다.
- 폰 노이만 방식의 컴퓨터에서는 중앙 처리기가 명령어 인출 주기동안 주메모리로부터 명령어를 읽고 자료 인출 주기 동안 주메모리로부터 데이터를 읽고 쓴다.
- CPU가 디스크에서 가져온 데이터를 처리하기위해 데이터는 CPU가 생성한 입출력 호출에 의해 주 메모리로 전송되어야한다. 
- CPU가 명령을 실행하기 위해서는 명령이 주 메모리 내에 있어야 한다.
- 프로그램이 실행되기 위해서는 반드시 절대 주소로 맵핑되고 메모리에 적재되어야 한다.
- 프로그램을 실행하며 절대 주소를 생성하여 메모리의 프로그램명령어와 데이터에 접근한다.
- 프로그램이 종료되면 프로그램이 차지하던 메모리 공간은 가용공간으로 선언되고 다음 프로그램이 적재되어 실행될 수 있다.
- CPU 이용률과 컴퓨터 응답 속도를 개선하기 위해 메모리에 여러 프로그램을 유지해야 하며 이를 위해 메모리 관리 기법이 필요하다.
- 메모리 관리 기법은 특히 시스템의 하드웨어 설계에 좌우된다.

> 운영체제는 메모리 관리와 관련하여 다음과 같은 일의 담당해야 한다.
> 1. 메모리의 현재 어느 부분이 사용되고 있으며 누구에 의해 사용되고 있는지를 추적해야 한다.
> 2. 어떤 프로세스(또는 그 일부)들을 메모리에 적재하고 제거할 것인가를 결정해야 한다.
> 3. 필요에 따라 메모리 공간을 할당하고 회수해야 한다.
